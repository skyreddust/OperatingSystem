进程切换带来系统开销，切换次数越多，开销越大
当前进程的时间片用完后，其状态由执行态变为就绪态
时钟中断是系统中特定的周期性时钟节拍，操作系统通过它来确定时间间隔，实现时间的延时和任务的超时
现代操作系统为了保证性能最优，通常根据响应时间、系统开销、进程数量、运行时间等因素确定时间片大小

【例题】408 2017 27

同步互斥机制：
·空闲让进：临界区空闲时，应允许一个进程访问。
·忙则等待：临界区正在被访问时，其他要访问的进程需等待。
·有限等待：进程不能一直等待临界区释放，否则出现“饥饿”现象。
·让权等待：进不了临界区的进程要下处理机，以免进程陷入“忙等”状态。
【注】注意区别“忙则等待”、“有限等待”和“让权等待”：违反“有限等待”是有人想进临界区，但一直进不了，一直死等；违反“让权等待”是有人进了临界区，其他人在干等这个人退出临界区；违反“忙则等待”是有人进了临界区，其他人也闯进来了。
单标志检查法	在进入区只“检查”，不“上锁”	违反“空闲让进”
双标志先检查法	在进入区先“检查”后“上锁”，退出区“解锁”	违反“忙则等待”
双标志后检查法	在进入区先“上锁”后“检查”，退出区“解锁”	违反“空闲让进”“有限等待”
Peterson 算法	在进入区“主动争取-主动谦让-检查对方是否想进、己方是否谦让”	违反“让权等待”
【注】只有违反“有限等待”的算法可能导致饥饿现象

中断屏蔽方法	利用“开/关中断指令”实现	简单高效	只适用于单处理机，只适用于操作系统内核进程
TestAndSet 指令（TSL 指令）	使用变量 old 记录原来 lock 的值，再将 lock 设为 true，最后不断检查临界区是否已被其他进程上锁	实现简单，适用于多处理机	不满足让权等待
Swap 指令	逻辑上同 TSL 指令	实现简单，适用于多处理机	不满足让权等待

P 操作负责分配资源，没有资源的时候就等着（进入阻塞队列）。V 操作负责释放资源，在阻塞队列不为空的时候唤醒某个进程进入临界区

死锁的四个必要条件：
互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。
不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。
请求并保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。
循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。

若系统有 x 个进程，每个进程需要 y 个资源，则该系统必然不会发生死锁的最少资源是 x*(y-1) + 1 个。
若系统有 x 个资源，每个进程需要 y 个资源，则该系统可能发生死锁的最小进程数为 x / (y-1)。

死锁预防（不允许死锁发生-静态策略）：
破坏互斥条件	把互斥资源改造为共享资源（如 SPOOLing 技术）	可行性不高
破坏不剥夺条件	（1）申请的资源得不到满足时，立即释放拥有的所有资源；（2）申请的资源被其他进程占用时，由操作系统协助剥夺	可能导致进程部分工作失效，系统开销大，可能引起饥饿
破坏请求并保持条件	运行前分配好所有需要的资源，之后一直保持	资源利用率高，可能引起饥饿
破坏循环等待条件	给资源编号，必须按编号递增的顺序请求资源	用户编程麻烦，不方便新增新设备，资源浪费

死锁避免（不允许死锁发生-动态策略）：
安全性算法和银行家算法
【注】如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁

死锁检测和解除（允许死锁发生）：
死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁。注意，并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程
死锁解除：资源剥夺法；撤销进程法；进程回退法
